/* automatically generated by rust-bindgen 0.63.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TIME_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 1024;
pub const FREENECT_COUNTS_PER_G: u32 = 819;
pub const FREENECT_DEPTH_MM_MAX_VALUE: u32 = 10000;
pub const FREENECT_DEPTH_MM_NO_VALUE: u32 = 0;
pub const FREENECT_DEPTH_RAW_MAX_VALUE: u32 = 2048;
pub const FREENECT_DEPTH_RAW_NO_VALUE: u32 = 2047;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub const freenect_device_flags_FREENECT_DEVICE_MOTOR: freenect_device_flags = 1;
pub const freenect_device_flags_FREENECT_DEVICE_CAMERA: freenect_device_flags = 2;
pub const freenect_device_flags_FREENECT_DEVICE_AUDIO: freenect_device_flags = 4;
#[doc = " Flags representing devices to open when freenect_open_device() is called.\n In particular, this allows libfreenect to grab only a subset of the devices\n in the Kinect, so you could (for instance) use libfreenect to handle audio\n and motor support while letting OpenNI have access to the cameras.\n If a device is not supported on a particular platform, its flag will be ignored."]
pub type freenect_device_flags = ::std::os::raw::c_uint;
#[doc = " A struct used in enumeration to give access to serial numbers, so you can\n open a particular device by serial rather than depending on index.  This\n is most useful if you have more than one Kinect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct freenect_device_attributes {
    pub next: *mut freenect_device_attributes,
    pub camera_serial: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_freenect_device_attributes() {
    const UNINIT: ::std::mem::MaybeUninit<freenect_device_attributes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<freenect_device_attributes>(),
        16usize,
        concat!("Size of: ", stringify!(freenect_device_attributes))
    );
    assert_eq!(
        ::std::mem::align_of::<freenect_device_attributes>(),
        8usize,
        concat!("Alignment of ", stringify!(freenect_device_attributes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_device_attributes),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).camera_serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_device_attributes),
            "::",
            stringify!(camera_serial)
        )
    );
}
#[doc = "< QVGA - 320x240"]
pub const freenect_resolution_FREENECT_RESOLUTION_LOW: freenect_resolution = 0;
#[doc = "< VGA  - 640x480"]
pub const freenect_resolution_FREENECT_RESOLUTION_MEDIUM: freenect_resolution = 1;
#[doc = "< SXGA - 1280x1024"]
pub const freenect_resolution_FREENECT_RESOLUTION_HIGH: freenect_resolution = 2;
#[doc = "< Dummy value to force enum to be 32 bits wide"]
pub const freenect_resolution_FREENECT_RESOLUTION_DUMMY: freenect_resolution = 2147483647;
#[doc = " Enumeration of available resolutions.\n Not all available resolutions are actually supported for all video formats.\n Frame modes may not perfectly match resolutions.  For instance,\n FREENECT_RESOLUTION_MEDIUM is 640x488 for the IR camera."]
pub type freenect_resolution = ::std::os::raw::c_uint;
#[doc = "< Decompressed RGB mode (demosaicing done by libfreenect)"]
pub const freenect_video_format_FREENECT_VIDEO_RGB: freenect_video_format = 0;
#[doc = "< Bayer compressed mode (raw information from camera)"]
pub const freenect_video_format_FREENECT_VIDEO_BAYER: freenect_video_format = 1;
#[doc = "< 8-bit IR mode"]
pub const freenect_video_format_FREENECT_VIDEO_IR_8BIT: freenect_video_format = 2;
#[doc = "< 10-bit IR mode"]
pub const freenect_video_format_FREENECT_VIDEO_IR_10BIT: freenect_video_format = 3;
#[doc = "< 10-bit packed IR mode"]
pub const freenect_video_format_FREENECT_VIDEO_IR_10BIT_PACKED: freenect_video_format = 4;
#[doc = "< YUV RGB mode"]
pub const freenect_video_format_FREENECT_VIDEO_YUV_RGB: freenect_video_format = 5;
#[doc = "< YUV Raw mode"]
pub const freenect_video_format_FREENECT_VIDEO_YUV_RAW: freenect_video_format = 6;
#[doc = "< Dummy value to force enum to be 32 bits wide"]
pub const freenect_video_format_FREENECT_VIDEO_DUMMY: freenect_video_format = 2147483647;
#[doc = " Enumeration of video frame information states.\n See http://openkinect.org/wiki/Protocol_Documentation#RGB_Camera for more information."]
pub type freenect_video_format = ::std::os::raw::c_uint;
#[doc = "< 11 bit depth information in one uint16_t/pixel"]
pub const freenect_depth_format_FREENECT_DEPTH_11BIT: freenect_depth_format = 0;
#[doc = "< 10 bit depth information in one uint16_t/pixel"]
pub const freenect_depth_format_FREENECT_DEPTH_10BIT: freenect_depth_format = 1;
#[doc = "< 11 bit packed depth information"]
pub const freenect_depth_format_FREENECT_DEPTH_11BIT_PACKED: freenect_depth_format = 2;
#[doc = "< 10 bit packed depth information"]
pub const freenect_depth_format_FREENECT_DEPTH_10BIT_PACKED: freenect_depth_format = 3;
#[doc = "< processed depth data in mm, aligned to 640x480 RGB"]
pub const freenect_depth_format_FREENECT_DEPTH_REGISTERED: freenect_depth_format = 4;
#[doc = "< depth to each pixel in mm, but left unaligned to RGB image"]
pub const freenect_depth_format_FREENECT_DEPTH_MM: freenect_depth_format = 5;
#[doc = "< Dummy value to force enum to be 32 bits wide"]
pub const freenect_depth_format_FREENECT_DEPTH_DUMMY: freenect_depth_format = 2147483647;
#[doc = " Enumeration of depth frame states\n See http://openkinect.org/wiki/Protocol_Documentation#RGB_Camera for more information."]
pub type freenect_depth_format = ::std::os::raw::c_uint;
pub const freenect_flag_FREENECT_AUTO_EXPOSURE: freenect_flag = 16384;
pub const freenect_flag_FREENECT_AUTO_WHITE_BALANCE: freenect_flag = 2;
pub const freenect_flag_FREENECT_RAW_COLOR: freenect_flag = 16;
pub const freenect_flag_FREENECT_MIRROR_DEPTH: freenect_flag = 65536;
pub const freenect_flag_FREENECT_MIRROR_VIDEO: freenect_flag = 131072;
pub const freenect_flag_FREENECT_NEAR_MODE: freenect_flag = 262144;
#[doc = " Enumeration of flags to toggle features with freenect_set_flag()"]
pub type freenect_flag = ::std::os::raw::c_uint;
pub const freenect_flag_value_FREENECT_OFF: freenect_flag_value = 0;
pub const freenect_flag_value_FREENECT_ON: freenect_flag_value = 1;
#[doc = " Possible values for setting each `freenect_flag`"]
pub type freenect_flag_value = ::std::os::raw::c_uint;
#[doc = " Structure to give information about the width, height, bitrate,\n framerate, and buffer size of a frame in a particular mode, as\n well as the total number of bytes needed to hold a single frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct freenect_frame_mode {
    #[doc = "< unique ID used internally.  The meaning of values may change without notice.  Don't touch or depend on the contents of this field.  We mean it."]
    pub reserved: u32,
    #[doc = "< Resolution this freenect_frame_mode describes, should you want to find it again with freenect_find_*_frame_mode()."]
    pub resolution: freenect_resolution,
    pub __bindgen_anon_1: freenect_frame_mode__bindgen_ty_1,
    #[doc = "< Total buffer size in bytes to hold a single frame of data.  Should be equivalent to width * height * (data_bits_per_pixel+padding_bits_per_pixel) / 8"]
    pub bytes: i32,
    #[doc = "< Width of the frame, in pixels"]
    pub width: i16,
    #[doc = "< Height of the frame, in pixels"]
    pub height: i16,
    #[doc = "< Number of bits of information needed for each pixel"]
    pub data_bits_per_pixel: i8,
    #[doc = "< Number of bits of padding for alignment used for each pixel"]
    pub padding_bits_per_pixel: i8,
    #[doc = "< Approximate expected frame rate, in Hz"]
    pub framerate: i8,
    #[doc = "< If 0, this freenect_frame_mode is invalid and does not describe a supported mode.  Otherwise, the frame_mode is valid."]
    pub is_valid: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union freenect_frame_mode__bindgen_ty_1 {
    pub dummy: i32,
    pub video_format: freenect_video_format,
    pub depth_format: freenect_depth_format,
}
#[test]
fn bindgen_test_layout_freenect_frame_mode__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<freenect_frame_mode__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<freenect_frame_mode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(freenect_frame_mode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<freenect_frame_mode__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(freenect_frame_mode__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode__bindgen_ty_1),
            "::",
            stringify!(video_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode__bindgen_ty_1),
            "::",
            stringify!(depth_format)
        )
    );
}
#[test]
fn bindgen_test_layout_freenect_frame_mode() {
    const UNINIT: ::std::mem::MaybeUninit<freenect_frame_mode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<freenect_frame_mode>(),
        24usize,
        concat!("Size of: ", stringify!(freenect_frame_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<freenect_frame_mode>(),
        4usize,
        concat!("Alignment of ", stringify!(freenect_frame_mode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_bits_per_pixel) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(data_bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_bits_per_pixel) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(padding_bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_frame_mode),
            "::",
            stringify!(is_valid)
        )
    );
}
#[doc = "< Turn LED off"]
pub const freenect_led_options_LED_OFF: freenect_led_options = 0;
#[doc = "< Turn LED to Green"]
pub const freenect_led_options_LED_GREEN: freenect_led_options = 1;
#[doc = "< Turn LED to Red"]
pub const freenect_led_options_LED_RED: freenect_led_options = 2;
#[doc = "< Turn LED to Yellow"]
pub const freenect_led_options_LED_YELLOW: freenect_led_options = 3;
#[doc = "< Make LED blink Green"]
pub const freenect_led_options_LED_BLINK_GREEN: freenect_led_options = 4;
#[doc = "< Make LED blink Red/Yellow"]
pub const freenect_led_options_LED_BLINK_RED_YELLOW: freenect_led_options = 6;
#[doc = " Enumeration of LED states\n See http://openkinect.org/wiki/Protocol_Documentation#Setting_LED for more information."]
pub type freenect_led_options = ::std::os::raw::c_uint;
#[doc = "< Tilt motor is stopped"]
pub const freenect_tilt_status_code_TILT_STATUS_STOPPED: freenect_tilt_status_code = 0;
#[doc = "< Tilt motor has reached movement limit"]
pub const freenect_tilt_status_code_TILT_STATUS_LIMIT: freenect_tilt_status_code = 1;
#[doc = "< Tilt motor is currently moving to new position"]
pub const freenect_tilt_status_code_TILT_STATUS_MOVING: freenect_tilt_status_code = 4;
#[doc = " Enumeration of tilt motor status"]
pub type freenect_tilt_status_code = ::std::os::raw::c_uint;
#[doc = " Data from the tilt motor and accelerometer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct freenect_raw_tilt_state {
    #[doc = "< Raw accelerometer data for X-axis, see FREENECT_COUNTS_PER_G for conversion"]
    pub accelerometer_x: i16,
    #[doc = "< Raw accelerometer data for Y-axis, see FREENECT_COUNTS_PER_G for conversion"]
    pub accelerometer_y: i16,
    #[doc = "< Raw accelerometer data for Z-axis, see FREENECT_COUNTS_PER_G for conversion"]
    pub accelerometer_z: i16,
    #[doc = "< Raw tilt motor angle encoder information"]
    pub tilt_angle: i8,
    #[doc = "< State of the tilt motor (stopped, moving, etc...)"]
    pub tilt_status: freenect_tilt_status_code,
}
#[test]
fn bindgen_test_layout_freenect_raw_tilt_state() {
    const UNINIT: ::std::mem::MaybeUninit<freenect_raw_tilt_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<freenect_raw_tilt_state>(),
        12usize,
        concat!("Size of: ", stringify!(freenect_raw_tilt_state))
    );
    assert_eq!(
        ::std::mem::align_of::<freenect_raw_tilt_state>(),
        4usize,
        concat!("Alignment of ", stringify!(freenect_raw_tilt_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accelerometer_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_raw_tilt_state),
            "::",
            stringify!(accelerometer_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accelerometer_y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_raw_tilt_state),
            "::",
            stringify!(accelerometer_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accelerometer_z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_raw_tilt_state),
            "::",
            stringify!(accelerometer_z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tilt_angle) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_raw_tilt_state),
            "::",
            stringify!(tilt_angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tilt_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(freenect_raw_tilt_state),
            "::",
            stringify!(tilt_status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _freenect_context {
    _unused: [u8; 0],
}
pub type freenect_context = _freenect_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _freenect_device {
    _unused: [u8; 0],
}
pub type freenect_device = _freenect_device;
pub type freenect_usb_context = ::std::os::raw::c_void;
#[doc = "< Log for crashing/non-recoverable errors"]
pub const freenect_loglevel_FREENECT_LOG_FATAL: freenect_loglevel = 0;
#[doc = "< Log for major errors"]
pub const freenect_loglevel_FREENECT_LOG_ERROR: freenect_loglevel = 1;
#[doc = "< Log for warning messages"]
pub const freenect_loglevel_FREENECT_LOG_WARNING: freenect_loglevel = 2;
#[doc = "< Log for important messages"]
pub const freenect_loglevel_FREENECT_LOG_NOTICE: freenect_loglevel = 3;
#[doc = "< Log for normal messages"]
pub const freenect_loglevel_FREENECT_LOG_INFO: freenect_loglevel = 4;
#[doc = "< Log for useful development messages"]
pub const freenect_loglevel_FREENECT_LOG_DEBUG: freenect_loglevel = 5;
#[doc = "< Log for slightly less useful messages"]
pub const freenect_loglevel_FREENECT_LOG_SPEW: freenect_loglevel = 6;
#[doc = "< Log EVERYTHING. May slow performance."]
pub const freenect_loglevel_FREENECT_LOG_FLOOD: freenect_loglevel = 7;
#[doc = " Enumeration of message logging levels"]
pub type freenect_loglevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Initialize a freenect context and do any setup required for\n platform specific USB libraries.\n\n @param ctx Address of pointer to freenect context struct to allocate and initialize\n @param usb_ctx USB context to initialize. Can be NULL if not using multiple contexts.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_init(
        ctx: *mut *mut freenect_context,
        usb_ctx: *mut freenect_usb_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Closes the device if it is open, and frees the context\n\n @param ctx freenect context to close/free\n\n @return 0 on success"]
    pub fn freenect_shutdown(ctx: *mut freenect_context) -> ::std::os::raw::c_int;
}
#[doc = " Typedef for logging callback functions"]
pub type freenect_log_cb = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut freenect_context,
        level: freenect_loglevel,
        msg: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Set the log level for the specified freenect context\n\n @param ctx context to set log level for\n @param level log level to use (see freenect_loglevel enum)"]
    pub fn freenect_set_log_level(ctx: *mut freenect_context, level: freenect_loglevel);
}
extern "C" {
    #[doc = " Callback for log messages (i.e. for rerouting to a file instead of\n stdout)\n\n @param ctx context to set log callback for\n @param cb callback function pointer"]
    pub fn freenect_set_log_callback(ctx: *mut freenect_context, cb: freenect_log_cb);
}
extern "C" {
    #[doc = " Calls the platform specific usb event processor\n\n @param ctx context to process events for\n\n @return 0 on success, other values on error, platform/library dependant"]
    pub fn freenect_process_events(ctx: *mut freenect_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls the platform specific usb event processor until either an event occurs\n or the timeout parameter time has passed.  If a zero timeval is passed, this\n function will handle any already-pending events, then return immediately.\n\n @param ctx Context to process events for\n @param timeout Pointer to a timeval containing the maximum amount of time to block waiting for events, or zero for nonblocking mode\n\n @return 0 on success, other values on error, platform/library dependant"]
    pub fn freenect_process_events_timeout(
        ctx: *mut freenect_context,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of kinect devices currently connected to the\n system\n\n @param ctx Context to access device count through\n\n @return Number of devices connected, < 0 on error"]
    pub fn freenect_num_devices(ctx: *mut freenect_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Scans for kinect devices and produces a linked list of their attributes\n (namely, serial numbers), returning the number of devices.\n\n @param ctx Context to scan for kinect devices with\n @param attribute_list Pointer to where this function will store the resultant linked list\n\n @return Number of devices connected, < 0 on error"]
    pub fn freenect_list_device_attributes(
        ctx: *mut freenect_context,
        attribute_list: *mut *mut freenect_device_attributes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the linked list produced by freenect_list_device_attributes().\n\n @param attribute_list Linked list of attributes to free."]
    pub fn freenect_free_device_attributes(attribute_list: *mut freenect_device_attributes);
}
extern "C" {
    #[doc = " Answer which subdevices this library supports.  This is most useful for\n wrappers trying to determine whether the underlying library was built with\n audio support or not, so the wrapper can avoid calling functions that do not\n exist.\n\n @return Flags representing the subdevices that the library supports opening (see freenect_device_flags)"]
    pub fn freenect_supported_subdevices() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set which subdevices any subsequent calls to freenect_open_device()\n should open.  This will not affect devices which have already been\n opened.  The default behavior, should you choose not to call this\n function at all, is to open all supported subdevices - motor, cameras,\n and audio, if supported on the platform.\n\n @param ctx Context to set future subdevice selection for\n @param subdevs Flags representing the subdevices to select"]
    pub fn freenect_select_subdevices(ctx: *mut freenect_context, subdevs: freenect_device_flags);
}
extern "C" {
    #[doc = " Returns the devices that are enabled after calls to freenect_open_device()\n On newer kinects the motor and audio are automatically disabled for now\n\n @param ctx Context to set future subdevice selection for\n @return Flags representing the subdevices that were actually opened (see freenect_device_flags)"]
    pub fn freenect_enabled_subdevices(ctx: *mut freenect_context) -> freenect_device_flags;
}
extern "C" {
    #[doc = " Opens a kinect device via a context. Index specifies the index of\n the device on the current state of the bus. Bus resets may cause\n indexes to shift.\n\n @param ctx Context to open device through\n @param dev Device structure to assign opened device to\n @param index Index of the device on the bus\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_open_device(
        ctx: *mut freenect_context,
        dev: *mut *mut freenect_device,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Opens a kinect device (via a context) associated with a particular camera\n subdevice serial number.  This function will fail if no device with a\n matching serial number is found.\n\n @param ctx Context to open device through\n @param dev Device structure to assign opened device to\n @param camera_serial Null-terminated ASCII string containing the serial number of the camera subdevice in the device to open\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_open_device_by_camera_serial(
        ctx: *mut freenect_context,
        dev: *mut *mut freenect_device,
        camera_serial: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Closes a device that is currently open\n\n @param dev Device to close\n\n @return 0 on success"]
    pub fn freenect_close_device(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the device user data, for passing generic information into\n callbacks\n\n @param dev Device to attach user data to\n @param user User data to attach"]
    pub fn freenect_set_user(dev: *mut freenect_device, user: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Retrieve the pointer to user data from the device struct\n\n @param dev Device from which to get user data\n\n @return Pointer to user data"]
    pub fn freenect_get_user(dev: *mut freenect_device) -> *mut ::std::os::raw::c_void;
}
#[doc = " Typedef for depth image received event callbacks"]
pub type freenect_depth_cb = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut freenect_device,
        depth: *mut ::std::os::raw::c_void,
        timestamp: u32,
    ),
>;
#[doc = " Typedef for video image received event callbacks"]
pub type freenect_video_cb = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut freenect_device,
        video: *mut ::std::os::raw::c_void,
        timestamp: u32,
    ),
>;
#[doc = " Typedef for stream chunk processing callbacks"]
pub type freenect_chunk_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        pkt_data: *mut ::std::os::raw::c_void,
        pkt_num: ::std::os::raw::c_int,
        datalen: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Set callback for depth information received event\n\n @param dev Device to set callback for\n @param cb Function pointer for processing depth information"]
    pub fn freenect_set_depth_callback(dev: *mut freenect_device, cb: freenect_depth_cb);
}
extern "C" {
    #[doc = " Set callback for video information received event\n\n @param dev Device to set callback for\n @param cb Function pointer for processing video information"]
    pub fn freenect_set_video_callback(dev: *mut freenect_device, cb: freenect_video_cb);
}
extern "C" {
    #[doc = " Set callback for depth chunk processing\n\n @param dev Device to set callback for\n @param cb Function pointer for processing depth chunk"]
    pub fn freenect_set_depth_chunk_callback(dev: *mut freenect_device, cb: freenect_chunk_cb);
}
extern "C" {
    #[doc = " Set callback for video chunk processing\n\n @param dev Device to set callback for\n @param cb Function pointer for processing video chunk"]
    pub fn freenect_set_video_chunk_callback(dev: *mut freenect_device, cb: freenect_chunk_cb);
}
extern "C" {
    #[doc = " Set the buffer to store depth information to. Size of buffer is\n dependant on depth format. See FREENECT_DEPTH_*_SIZE defines for\n more information.\n\n @param dev Device to set depth buffer for.\n @param buf Buffer to store depth information to.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_set_depth_buffer(
        dev: *mut freenect_device,
        buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the buffer to store depth information to. Size of buffer is\n dependant on video format. See FREENECT_VIDEO_*_SIZE defines for\n more information.\n\n @param dev Device to set video buffer for.\n @param buf Buffer to store video information to.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_set_video_buffer(
        dev: *mut freenect_device,
        buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start the depth information stream for a device.\n\n @param dev Device to start depth information stream for.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_start_depth(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start the video information stream for a device.\n\n @param dev Device to start video information stream for.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_start_video(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the depth information stream for a device\n\n @param dev Device to stop depth information stream on.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_stop_depth(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the video information stream for a device\n\n @param dev Device to stop video information stream on.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_stop_video(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates the accelerometer state using a blocking control message\n call.\n\n @param dev Device to get accelerometer data from\n\n @return 0 on success, < 0 on error. Accelerometer data stored to\n device struct."]
    pub fn freenect_update_tilt_state(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the tilt state from a device\n\n @param dev Device to retrieve tilt state from\n\n @return The tilt state struct of the device"]
    pub fn freenect_get_tilt_state(dev: *mut freenect_device) -> *mut freenect_raw_tilt_state;
}
extern "C" {
    #[doc = " Return the tilt state, in degrees with respect to the horizon\n\n @param state The tilt state struct from a device\n\n @return Current degree of tilt of the device"]
    pub fn freenect_get_tilt_degs(state: *mut freenect_raw_tilt_state) -> f64;
}
extern "C" {
    #[doc = " Set the tilt state of the device, in degrees with respect to the\n horizon. Uses blocking control message call to update\n device. Function return does not reflect state of device, device\n may still be moving to new position after the function returns. Use\n freenect_get_tilt_status() to find current movement state.\n\n @param dev Device to set tilt state\n @param angle Angle the device should tilt to\n\n @return 0 on success, < 0 on error."]
    pub fn freenect_set_tilt_degs(dev: *mut freenect_device, angle: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the movement state of the tilt motor (moving, stopped, etc...)\n\n @param state Raw state struct to get the tilt status code from\n\n @return Status code of the tilt device. See\n freenect_tilt_status_code enum for more info."]
    pub fn freenect_get_tilt_status(
        state: *mut freenect_raw_tilt_state,
    ) -> freenect_tilt_status_code;
}
extern "C" {
    #[doc = " Set the state of the LED. Uses blocking control message call to\n update device.\n\n @param dev Device to set the LED state\n @param option LED state to set on device. See freenect_led_options enum.\n\n @return 0 on success, < 0 on error"]
    pub fn freenect_set_led(
        dev: *mut freenect_device,
        option: freenect_led_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the axis-based gravity adjusted accelerometer state, as laid\n out via the accelerometer data sheet, which is available at\n\n http://www.kionix.com/Product%20Sheets/KXSD9%20Product%20Brief.pdf\n\n @param state State to extract accelerometer data from\n @param x Stores X-axis accelerometer state\n @param y Stores Y-axis accelerometer state\n @param z Stores Z-axis accelerometer state"]
    pub fn freenect_get_mks_accel(
        state: *mut freenect_raw_tilt_state,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    );
}
extern "C" {
    #[doc = " Get the number of video camera modes supported by the driver.  This includes both RGB and IR modes.\n\n @return Number of video modes supported by the driver"]
    pub fn freenect_get_video_mode_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the frame descriptor of the nth supported video mode for the\n video camera.\n\n @param mode_num Which of the supported modes to return information about\n\n @return A freenect_frame_mode describing the nth video mode"]
    pub fn freenect_get_video_mode(mode_num: ::std::os::raw::c_int) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Get the frame descriptor of the current video mode for the specified\n freenect device.\n\n @param dev Which device to return the currently-set video mode for\n\n @return A freenect_frame_mode describing the current video mode of the specified device"]
    pub fn freenect_get_current_video_mode(dev: *mut freenect_device) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Convenience function to return a mode descriptor matching the\n specified resolution and video camera pixel format, if one exists.\n\n @param res Resolution desired\n @param fmt Pixel format desired\n\n @return A freenect_frame_mode that matches the arguments specified, if such a valid mode exists; otherwise, an invalid freenect_frame_mode."]
    pub fn freenect_find_video_mode(
        res: freenect_resolution,
        fmt: freenect_video_format,
    ) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Sets the current video mode for the specified device.  If the\n freenect_frame_mode specified is not one provided by the driver\n e.g. from freenect_get_video_mode() or freenect_find_video_mode()\n then behavior is undefined.  The current video mode cannot be\n changed while streaming is active.\n\n @param dev Device for which to set the video mode\n @param mode Frame mode to set\n\n @return 0 on success, < 0 if error"]
    pub fn freenect_set_video_mode(
        dev: *mut freenect_device,
        mode: freenect_frame_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of depth camera modes supported by the driver.  This includes both RGB and IR modes.\n\n @return Number of depth modes supported by the driver"]
    pub fn freenect_get_depth_mode_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the frame descriptor of the nth supported depth mode for the\n depth camera.\n\n @param mode_num Which of the supported modes to return information about\n\n @return A freenect_frame_mode describing the nth depth mode"]
    pub fn freenect_get_depth_mode(mode_num: ::std::os::raw::c_int) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Get the frame descriptor of the current depth mode for the specified\n freenect device.\n\n @param dev Which device to return the currently-set depth mode for\n\n @return A freenect_frame_mode describing the current depth mode of the specified device"]
    pub fn freenect_get_current_depth_mode(dev: *mut freenect_device) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Convenience function to return a mode descriptor matching the\n specified resolution and depth camera pixel format, if one exists.\n\n @param res Resolution desired\n @param fmt Pixel format desired\n\n @return A freenect_frame_mode that matches the arguments specified, if such a valid mode exists; otherwise, an invalid freenect_frame_mode."]
    pub fn freenect_find_depth_mode(
        res: freenect_resolution,
        fmt: freenect_depth_format,
    ) -> freenect_frame_mode;
}
extern "C" {
    #[doc = " Sets the current depth mode for the specified device.  The mode\n cannot be changed while streaming is active.\n\n @param dev Device for which to set the depth mode\n @param mode Frame mode to set\n\n @return 0 on success, < 0 if error"]
    pub fn freenect_set_depth_mode(
        dev: *mut freenect_device,
        mode: freenect_frame_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables or disables the specified flag.\n\n @param flag Feature to set\n @param value `FREENECT_OFF` or `FREENECT_ON`\n\n @return 0 on success, < 0 if error"]
    pub fn freenect_set_flag(
        dev: *mut freenect_device,
        flag: freenect_flag,
        value: freenect_flag_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the brightness of the IR sensor.\n\n @param dev Device to get IR brightness\n\n @return IR brightness value in the range 1 - 50, < 0 if error"]
    pub fn freenect_get_ir_brightness(dev: *mut freenect_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the brightness of the IR sensor.\n Note that this does not change the intensity of the IR projector.\n\n @param dev Device to set IR brightness\n @param brighness Brightness value in range 1 - 50\n\n @return 0 on success, < 0 if error"]
    pub fn freenect_set_ir_brightness(
        dev: *mut freenect_device,
        brightness: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allows the user to specify a pointer to the audio firmware in memory for the Xbox 360 Kinect\n\n @param ctx Context to open device through\n @param fw_ptr Pointer to audio firmware loaded in memory\n @param num_bytes The size of the firmware in bytes"]
    pub fn freenect_set_fw_address_nui(
        ctx: *mut freenect_context,
        fw_ptr: *mut ::std::os::raw::c_uchar,
        num_bytes: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Allows the user to specify a pointer to the audio firmware in memory for the K4W Kinect\n\n @param ctx Context to open device through\n @param fw_ptr Pointer to audio firmware loaded in memory\n @param num_bytes The size of the firmware in bytes"]
    pub fn freenect_set_fw_address_k4w(
        ctx: *mut freenect_context,
        fw_ptr: *mut ::std::os::raw::c_uchar,
        num_bytes: ::std::os::raw::c_uint,
    );
}
